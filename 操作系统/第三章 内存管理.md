# 第三章 内存管理
1. 什么是内存？有什么作用？
    内存可存放数据。程序执行前需要先放到内存中才能被CPU处理——缓解CPU与硬盘之间的速度矛盾
    多道程序设计中，如何区分各个程序的数据在内存中的位置：给内存中的存储单元编地址。每个地址对应一个存储单元。

指令的工作原理
内存的组成：程序段 数据段
指令中的地址指的是逻辑地址(相对地址)，即：相对于进程的起始地址而言的地址
问题：如何将逻辑地址转换成物理地址
## 内存管理的概念


### 内存管理的基本原理和要求
内存管理类的主要功能
1. 内存空间的分配与回收
1. 地址转换
1. 内存空间的扩充
1. 内存共享
1. 存储保护


#### 程序的链接与装入

程序链接有以下三种方式：
1. 静态链接：在程序运行前完成链接，需要解决两个问题1.修改相对地址 2.变换外部调用符号
1. 装入时动态链接：在装入内存时，采用边装入边链接的方式。便于修改和更新，便于实现对目标模块的共享
1. 运行时动态链接：在程序执行中需要该目标模块时才进行链接。优点：加快程序的装入过程，还可节省大量的内存空间。

内存的装入模块在装入内存时，同样有以下三种方式：
1. 绝对装入：要求知道装入模块会装到内存的什么位置，灵活性差，只适用于**单道程序环境**(此时还没有产生操作系统)：编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。**编译链接**后得到的装入模块的指令直接就使用了绝对地址。需要知道内存的装入地址。
1. 静态重定位：又称可重定位装入，编译、链接后形成的装入模块中的地址仍是从0开始的逻辑地址。将地址重定位是留在了**装入模块装入内存的时候**进行的。要求给作业分配的内存必须是连续的，也就是说必须在它执行前分配给该进程全部的内存空间，如果没有足够的内存空间就不能装入该作业。作业一旦进入内存，在运行期间就不能再移动了，也不能再申请内存空间了。否则会导致内存指向发生错误。(用于早期多道批处理系统)
1. 动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序吧装入模块装入内存后，并不会立即把逻辑地址转换为逻辑地址，而是**把地址转换推迟到程序真正要执行时才进行**。因此装入内存后的地址仍然是逻辑地址。这种方式需要一个**重定位寄存器**的支持。(现代操作系统使用)

### 从写程序到程序运行

源代码编译后成为目标模块，目标模块链接后成为装入模块(再windows系统下为.exe文件)。最后由装入程序将装入模块装入内存。

链接后形成完整的逻辑地址，装入后形成物理地址。

### 链接的三种方式
1. 静态链接：再程序运行之前，先将个目标模块及他们所需的库函数链接成一个完整的可执行文件(装入模块)，之后不在拆开。
1. 装入时动态链接：将各目标模块装入内存时，边装入边链接方式。
1. 运行时动态链接：在程序执行中才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。可以提高对内存的利用率。


### 内存管理的概念

1. 内存空间的分配与回收
1. 内存空间的扩充：操作系统需要提供某种技术从逻辑上对内存空间进行扩充
1. 地址转换：操作系统需要提供内存转换功能，负责程序的逻辑地址与物理地址的转换：三种装入方式
1. 内存保护：保证各道作业在内存中在各自的运行空间，互补干扰。
    1. 方法一：在CPU中设置一对上下限寄存器，存放进程的上下限地址。进程的指令要访问某个地址时，CPU检查是否越界。
    1. 方法二：采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称现场寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址，界地址寄存器中存放的是进程的最大的逻辑地址。
1. 内存共享：只允许多个进程访问内存的同一部分


### 覆盖与交换

#### 覆盖技术
解决程序大小超过内存总和的问题
将程序分为多个段，分为一个“固定区”和多个“覆盖区”
需要常驻内存的段放在“固定区”中，调入后就不在调出(除非运行结束)

必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。

#### 交换技术
也叫对换技术：内存空间紧张时，系统将内存中的某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘之间动态调度)
暂时换出外存等待的进程状态为挂起态
挂起态又进一步分为就绪挂起和阻塞挂起两种状态

1. 磁盘分为文件区和对换区。文件区主要用于存放文件，主要追求存储空间的效率，采用离散分配方式。对换区只占磁盘空间的一小部分，被换出的进程数据就存放在对换区，主要追求换入换出速度，采用连续分配方式。对换区的I/O速度比文件区更快。

1. 交换通常发生在内存吃紧时进行，比如发生经常发生缺页时。

1. 可优先换出阻塞进程，可换出优先级较低的进程：为了防止优先级低的进程频繁被换出，有的系统会考虑进程在内存的驻留时间。


### 连续分配管理方式

连续分配：系统为用户分配的是一个连续的内存空间。

+ 单一连续分配方式：内存分为系统区和用户区，内存中只能有一道用户程序。
优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定需要采取内存保护。
缺点： 只适用于单用户、单任务的操作系统；有内部碎片；存储器利用率极低。
+ 固定分区分配：
    1. 分区大小相等：将内存分为若干个固定大小的分区
        缺乏灵活性，但是很适合用于一台计算机控制多个相同对象的场合
    1. 分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业的大小情况进行划分
    
    使用分区说明表：每个对应表项包括对应分区的大小、起始地址、状态(是否已分配)
    优点：实现简单，无外部碎片
    缺点：1.当用户程序太大时，可能所有分区都不能满足需求，此时不得不采用覆盖技术来解决。2.会产生内部碎片，内存利用率低
    
+ 动态分区分配：即可变分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程大小动态的建立分区，并使分区的大小正好适合进程的需要
    1. 使用什么样的数据结构记录内存的使用情况？
    两种常用的数据结构：
        1. 空闲分区表
        1. 空闲分区链
    1. 当多个空闲分区都能满足需求时，应该选择哪个分区
        1. 首次适应(First Fit)，空闲分区以地址递增的顺序排列,每次都从链头开始搜索。
        2. 邻近适应(Next Fit)，又称循环首次适应算法，分配时从上次查找结束的位置开始。会使大地址的大分区被全部使用。
        3. 最佳适应(Best Fit),按容量递增的顺序排列，找到满足需求的最小分区.缺点：会留下很多外部碎片
        4. 最坏适应(Worst Fit)，按容量递减的次序排列，每次找到能满足需求的第一个空闲分区。
        首次适应算法最简单也通常最好和最快
    1. 如何进行分区的分配与回收？
    
    内部碎片：分配给某进程的内存区域中，如果有些部分没有用上
    外部碎片：是指内存中的某些空闲分区由于太小而难以利用
    可以采用紧凑技术来解决外部碎片的问题，即移动各个进程，使外部碎片合并，一般在装入时采用动态重定位的方式。方式

#### 基础分页存储

将内存空间分为一个个大小相等的分区，每个分区就是一个页框，(页框=页帧=内存块=物理块=物理页面)每个页框有一个编号，即“页框号”(页框号=页帧号=内存块号=物理块号=物理页号)，页框号从零开始。
将进程的逻辑地址空间分为与页框大小相同的一个个部分，每个部分称为一个“页”或“页框”。每个页面也有一个编号，即“页号”，页号也是从零开始。
操作系统以页框为单位为单位分配进程内存空间。进程的页面与内存的页框有一一对应的关系。各个页面不必连续存放，可以放到不相邻的页框中。

页表存在内存里，页号隐含在页表中。块号必须是整数字节。

逻辑地址转换为物理地址

#### 基本地址变换机构
页表寄存器：存放页表在内存中的起始位置F和页表长度M。在进程未上处理机时，F和M存放在进程控制块中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。
页式管理中的地址是一维的。
页表项不能跨页框存储，实际应用中，通常使一个页框恰好能存储整数个页表项。

#### 快表
又称联想寄存器

#### 两级页表

1.单机页表的问题：页表需要连续的存储在内存中，根据局部性原理，没有必要让所有页表都常驻内存
2.可以将页表进行分组，为分组再建立一个页表，称为**页目录表**，页目录表存储了存储二级页表的内存块号。
3.逻辑地址划分为一级页号、二级页号、页内偏移
4.可以在页表项中增加一个标志位，用于标识该页面是否已经进入了内存

采用多级页表机制，**各级页表的大小不能超过一个页面**

两级页表的访存次数：访问一个逻辑地址，需要三次访存


#### 基础分段式管理方式

