# PV大题解构

## 分析过程 
P占用/消耗 V释放/生产
1. 有几类进程？——每类进程对应一个函数
1. 在函数的内部，用中文描述动作$\Rightarrow$只做一次?（不加while）不断重复？（while循环）
1. 在每一个动作之前，是否需要P什么？若写P，则必V（注意隐含的互斥，缓冲区访问）
1. 所有PV写完之后，再去定义信号量
1. 检查多个P操作（请求和保持）连续出现的情况，是否可能产生死锁?
    1. 如果某个信号量的PV连续出现则不可能死锁（对一个信号量的PV之间没有其他的P）
    1. 连续多个P导致的死锁可以尝试调整P的顺序

**先P同步信号量，再P互斥信号量**
## 例题

### 生产者-消费者问题

1. 两个生产车间和一个装配车间，两个生产车间分别生产A、B两种零件，装配车间将A、B组装成产品，货架F1、F2分别存放A、B，其容量均为10，装配工人每次从货架上取一个A和一个B后组装成产品。

P1()：生产A零件，A装到F1
``` c
    while(1){
    生产A零件;
    
    P(F1); // 占用F1的资源
    P(M1);
    A装到F1;
    V(M1);
    V(FULL1); //生产A零件
}
```
P2()：生产B零件，B装到F2
``` c
    while(1){
    生产B零件;
    P(F2);
    P(M2);
    B装到F2;
    V(M2);
    V(FULL2); //生产B零件
}
```
C():从F1取A，从F2取B，组装成A+B
``` c
    while(1){
    P(FULL1); //消耗A零件
    P(M1);
    从F1取A；
    V(M1);
    V(F1);
    P(FULL2);
    P(M2);
    从F2取B；
    V(M2);
    V(F2);
    组装成A+B
}
```
F1 = 10 
F2 = 10 //F1,F2对应货架的剩余容量
FULL1 = 0
FULL2 = 0 // FULL1,2表示货架F1和F2上有几个零件
M1, M2 = 1  // 表示两个货架是否可以被访问
先P同步信号量，再P互斥信号量

2. 2014年真题
    两类进程：生产者和消费者
生产者进程Producer()
``` c
    while(1){
    
    生产一个产品;
    P(empty)
    P(M1)
    产品放入缓冲区;
    V(M1)
    V(full)
}
    
```

消费者进程 C()
``` c
    while(1){
    P(M2)
    for(int i = 0; i < 10 ; i++>){
    P(full)
}
    V(M2) //M2用于保证消费者进程取到十个产品
    P(M1)
    取10个产品;
    V(M1)
    for(int i = 0; i < 10 ; i++>){
    V(empty)
}
}

```
empty = 1000 
full = 0
M1 = 1
M2 = 1

3. 王道P111 08
两个进程：小和尚  老和尚

老和尚
``` c
    while(1){ 
    P(full); //先确定水缸中有水再去提桶
    P(tong);
    P(gang);
    从水缸中打一桶水；
    V(gang);
    喝水;
    V(empty);
    V(Tong);
}
```

小和尚
```c
    while(1){
    P(empty);// 先确保水缸中有空位再提桶
    P(tong);
    P(jing) ;   
    从井中打一桶水
    V(jing);
    P(gang);
    将水倒入水缸中
    V(gang);
    V(full);
    V(tong);
    }
```

### 理发师问题

4. 王道p113 14

理发师进程
```c
Tony(){
    
    P(cus); //检查是否有顾客
    
    while(1){
    
    }
}
``` 
   
顾客进程
``` c
C(){
    Tony在忙？
    
}
```

### 读者-写者问题
同类进程可以共享互斥资源，如过路问题，但不同类进程是互斥的
第一个读者负责上锁，最后一个读者负责解锁
需要有一个或多个count变量记录此时有几个同类进程在使用这个资源,对count变量的访问用P和V保证它的互斥
1. 王道p112 10

P1：从北到南
``` c
int count1 = 0;

P1(){
    P(mutexNS);
    if(count1 == 0)
        P(bridge);
    count1 ++ ;
    V(mutexSN);
    过桥
    count1 --；
    P(mutexNS);
    if(count1 == 0)
        V(bridge);
    V(mutexNS);
}
```
P2：从南到北
``` c

int count2 = 0;

P2(){
    P(mutexSN);
    if(count2 == 0)
        P(bridge);
    count2 ++ ;
    V(mutexSN);
    过桥
    P(mutexSN);
    count2 --；
    if(count2 == 0)
        V(bridge);
    V(mutexSN);
}
```

2. P113 15.
与上一个题相同

### 哲学家进餐问题
一类进程，同时需要多种资源
三种思路
    1. 限制申请条件，解法一不通用
    1. 信号量限制并行数，解法二通用
    1. 限制哲学家只有能够取得两个筷子的时候从才会就餐，解法三通用，先上锁，然后检查资源是否足够，如果够，直接全部拿走。

1.2019年真题

``` c
int mutex = 1;
int wan = m;
int a[n] = {1,1,1,1, ... ,1};

P(){
    while(1){
    P(mutex);
    if(资源足够)
        全部占用

    V(mutex);
}
}

```