# 进程与线程

### 进程的概念
为了使参与并发执行的每个程序(含数据)，都能独立地运行，必须为之配置一个专门的数据结构，称为**进程控制块**(Process Control Block,PCB)。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应的，由程序段、相关数据段和PCB三部分构成了**进程实体**(又称进程映像)。
创建进程实质上是创建进程实体中的PCB，撤销进程，实质上是撤销进程的PCB。值得注意的是，进程实体是静态的，进程则是动态的。进程实体反映了进程在某一时刻的状态。

**PCB是进程存在的唯一标志**

从不同的角度，进程的定义是不同的，比较典型的定义有：
1. 进程是程序的一次执行
1. 进程是一个程序机器数据在处理机上顺序执行时所发生的活动
1. 进程时具有独立功能的程序在一个数据集合上的运行的过程，它是系统进行资源分配和电镀的一个独立单位。

引入进程实体的概念之后，我们可以给出如下定义：
**进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

### 进程的组成
+ PCB
    + 进程描述信息
    + 进程控制和管理信息
    + 资源分配清单
    + 处理机相关信息
+ 程序段
    + 程序的代码(指令序列)
+ 数据段
    + 运行过程中产生的各种数据(如：程序中定义的变量)


### 进程的特征
1. 动态性：进程最基本的特性
1. 并发性
1. 独立性：进程是能独立运行的、独立获得资源、独立接收调度的基本单位
1. 异步性：各进程以不可预知的速度向前推进，可能导致运行结果的不确定性
1. 结构性

***

### 进程的状态与转换

#### 进程的状态

1. 运行态：进程正在处理机上运行。CPU会执行该进程对应的程序(执行指令序列)在单处理机中，每个时刻只有一个进程处于运行态
1. 就绪态：进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行，系统中处于就绪态的进程可能有多个，通常将它们排成一个队列，称为就绪队列
1. 阻塞态：又称**等待态**，进程正在等待某一事件而暂停运行，如等待某资源为可用(不包括处理机)或等待输入/输出完成。即使处理机空闲，该进程也不能运行。系统通常将处于阻塞态的进程也排列成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列
1. 创建态：进程正在被创建，尚未转到就绪态。创建进程需要多个步骤：首先申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后把该进程转入就绪态并插入就绪队列。但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。
1. 结束态：进程正从系统中小时，可能是进程正常结束或其他原因停止运行。进程需要结束运行时，系统首先将该进程置为结束态，然后进一步处理资源释放和回收工作

三种基本状态：运行态，就绪态，阻塞态，进程整个生命周期中，大部分事件都处于这三种状态

进程PCB中，会有一个变量state来表示进程当前状态。为了对同一个状态下的各个进程进行同一的管理，操作系统会将各个进程的PCB组织起来。

#### 进程状态的转换

就绪态→运行态：进程被调度
运行态→就绪态：时间片到，或CPU被其他高优先级的进程抢占
运行态→阻塞态:一个主动的过程，等待系统资源分配，或等待某事件发生
阻塞态→就绪态：资源分配到位，等到的事情发生(被动行为)
创建态→就绪态：系统完成进程创建的相关工作
运行态→终止态：进程运行结束，或运行过程中遇到不可修复的错误

#### 进程的组织方式
链接方式：
执行指针：指向当前处于运行态(执行态)的进程
就绪队列指针：指向当前处于就绪态的进程，通常会把优先级高的进程放在队头
阻塞队列指针：指向当前处于阻塞态的进程，很多操作系统中会根据阻塞原因的不同，将阻塞队列分为多个

***

### 进程控制
进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

如何实现进程控制？
使用**原语**，原语是一种特殊的程序，其执行具有“原子性”，即执行过程一气呵成，期间不允许被中断。通过关中断和开中断两个特权指令实现原子性。

#### 进程控制相关的原语

**进程的创建**
+ 创建原语：申请空白PCB，为新进程分配所需资源，初始化PCB，将PCB插入就绪队列

+ 引起进程创建阿事件：
    + 用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程
    + 作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程(作业：放在外存中还未投入运行的程序)
    + 提供服务：用户向操作系统提出某些请求时会新建一个进程处理该请求
    + 应用请求 ：由用户进程主动请求创建一个子进程

**进程的终止**
+ 撤销原语
    + 从PCB集合中找到终止进程的PCB
    + 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程
    + 终止其所有子进程(进程间的关系是树形结构)
    + 将该进程拥有的所有资源归还给父进程或操作系统
    + 删除PCB
+ 引起进程终止的事件
    + 正常结束：进程自己请求终止
    + 异常结束：整数除以0、非法使用特权指令，然后被操作系统强行杀掉
    + 外界干预：用户选择杀掉进程

**进程的阻塞和唤醒**
+ 进程的阻塞
    + 阻塞原语
    + 引起进程阻塞的事件
+ 进程的唤醒
    + 唤醒原语
    + 引起进程唤醒的事件

一个进程是因为何事阻塞就必须因为何事唤醒，因此阻塞原语和唤醒原语应该是成对使用的。

**进程的切换**
+ 切换原语
    + 将运行环境信息存入PCB
    + PCB移入相应队列
    + 选择另一个进程执行，并更新其PCB
    + 根据PCB恢复新近还曾所需的运行环境
+ 引起进程切换的事件
    + 当前进程时间片到
    + 有更高优先级的进程到达
    + 当前进程主动阻塞
    + 当前进程终止

***

### 进程间通信

进程间通信(Inter-Process Communication,IPC)是指两个进程之间产生数据交互。

+ 共享存储
设置一个共享额你存区域，并映射到进程的虚拟地址空间
在通信的进程之间存在一块可直接访问的共享空间。需要保证各个进程对共享存储区的访问是互斥的。
**基于存储区的共享**：操作系统在内存中画出一块共享存储区，数据的形式，存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快、灵活性高，是一种高级通信方式。
**基于数据结构的共享**：共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。
+ 消息传递
进程间的数据狡猾以格式化的消息为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。
    + **直接通信方式**消息发送进程要指明接收进程的ID。
    消息包括消息头和消息体，消息头包括：发送进程ID，接收进程ID、消息长度等格式化的信息。消息体中包含具体的数据。操作系统内核中包含进程的PCB,PCB中包含该进程的消息队列。
    发送原语指明消息的接收者，发送原语会导致操作系统内核接收到消息，并将该消息挂到接收者的消息队列，接收者使用一个接收原语指明接收的消息来自哪一个进程。
    + **间接通信方式**通过“信箱”间接地通信，又称为“信箱通信方式”
    进程P发往进程Q。进程P**发送原语**指明发往哪个信箱，进程Q通过**接收原语**指明从哪个信箱接收消息。可以多个进程往同一个
+ 管道通信
写进程从管道的一边写入数据，读进程从另一边读取数据。
管道是一个特殊的文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区。
写进程写数据和读进程读数据时要遵循先进先出的原则。而共享存储的读写进程可以在共享存储区的任意位置进行读写操作。
一个管道只能支持半双工通信。如果要实现双向同时通信，则需要设置两个管道。
各个进程要互斥的访问管道(由操作系统实现)
当管道被写满时，写进程将被阻塞，直到写进程往管道中写入数据，即可唤醒读进程
管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常由两种解决方案：1.**一个管道允许多个写进程，一个读进程**(2014年408真题高教社官方答案)2.允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据(Linux方案)。在做题时以第一种解决方案为准。
写进程往管道写数据，即使管道没被写满，只要管道没空，读进程就可以从管道读数据
读进程从管道读数据，即使管道没被读空，只要管道没满，写进程就可以向管道写数据


### 线程的概念
有的进程可能需要同时做很多时，而传统的进程只能串行地执行一系列程序。为此，引入了线程，来增加并发度。
引入了线程后，线程就成了程序执行流地最小单位
可以把线程理解为“轻量级进程”
引入线程后，进程只作为除CPU之外地系统资源的分配单元(如打印机、内存地址空间等都是被分配给进程的，而不是分配给线程的)，线程时调度的基本单位。
传统进程机制中，只能进程间并发，引入线程后，各线程之间也可以并发，提升了并发度。
传统的进程间并发，需要切换进程的运行环境，系统开销很大，线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小，引入线程后，并发所带来的系统开销减小

### 线程的实现方式

+ 用户级线程
线程切换的管理是由用户完成的，不需要操作系统的草鱼
线程切换不需要切换操作系统的状态
操作系统无法意识到线程的存在

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

+ 内核级线程
操作系统支持的线程(Kernel-Level Thread,KLT,又称“内核支持的线程”)
1. 内核级线程有操作系统内核管理
1. 内核级线程的切换必须在核心态下才能完成
1. 从操作系统的内核视角能看到内核级线程

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行
缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

+ 多线程模型
在支持内核级线程的操作系统中加入线程库，就可以实现把若干过用户级线程映射到某一个内核级线程。
1. 一对一模型：一个用户级线程对应一个内核级线程(退化成了内核级线程模型)
优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行
缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
2. 多对一模型：多个用户级线程对应一个内核级线程(退化成了用户级线程的模型)，一个用户进程对应一个内核级线程
优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。
3. 多对多模型：n个用户级线程对应m个内核级线程(n≥m)。每个用户进程对应m个内核级线程。
克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户占用太多内核级线程，开销太大的缺点

可以这么理解：
用户级线程是“代码逻辑”的载体：用户级线程对应不同的逻辑功能
内核级线程是“运行机会”的载体：操作系统在分配处理机资源时是以内核级线程为基本单位的
一段代码逻辑只有获得了运行机会才能被COU执行。
一个用户进程对应多个内核级线程时，只有所有的内核级线程都被阻塞，才说这个进程进入了阻塞态。

### 线程的状态与转换
通常只关注就绪态、运行态、阻塞态三种状态
其状态转换的条件与进程相同

### 线程的组织与控制
线程对应的数据结果为**TCB(线程控制块)**
包括以下内容：
+ 线程标识符：TID，与PID类似
+ 程序计数器PC
+ 其他寄存器：线程运行的中间结果
+ 堆栈指针：堆栈保存函数调用信息、局部变量等
+ 线程运行状态：运行/阻塞/就绪
+ 优先级：线程调度、资源分配的参考
其中PC、其他寄存器、堆栈指针在线程切换时要进行保存/恢复

**线程表**(thread table)
可以将多个TCB组织成一张线程表
线程表有多种组织方式：一个进程所包含的线程组成一个表；一个系统中所有的线程组成一个表；同一状态的线程组成一个表等

---

## 习题2.1

2.线程是处理机调度的基本单位，可以独立执行程序。
各个线程共享其所属进程的空间

4.进程与线程的根本区别是动态和静态的特点

6.操作系统是根据进程控制块进行控制和管理的。进程的基本状态和进程的优先权都属于PCB的一部分

9.一个进程释放了一台打印机，它可能会改变另一个等待打印机的进程。
进程执行完毕之后由运行态进入终止态并释放打印机，是因为自身状态改变才释放了打印机，而不是释放打印机导致自身状态改变

12.并发进程失去封闭性，是指并发进程共享变量，器质性结果与速度有关。进程的封闭性是指进程的执行结果只取决于进程本身，与执行速度无关。

15.引入线程后，进程仍然是资源分配的基本单位。内核级线程是处理机调度和分派的单位，线程本身不具有资源，它可以共享所属进程的全部资源。

20.若一个进程实体由PCB、共享正文段、数据堆段、数据栈段组成，请指出下列C语言程序中的内容及相关数据分别处于哪一段中：
全局复制变量：正文段
未赋值的全局变量：栈段
函数调用的实参传递值：栈段
用malloc()要求动态分配的存储区：堆段
常量值：正文段
进程的优先级：PCB

22.系统动态DLL库中的系统线程，被不同的进程所调用，它们是**相同**的线程。同一个系统的进程(线程)可以由系统调用的方法被不同的进程(或线程)多次使用。

23.PCB是进程存在的唯一标志。进程ID，CPU状态(CPU现场信息)，堆栈指针都属于PCB。全局变量不属于PCB。

43.进程可以创建进程和线程，线程只能创建线程。

46.用户级线程：一个线程阻塞时其他线程也会被阻塞。

55.当被阻塞的进程等待的某资源(除处理机外)可用时，进程将被唤醒。

二、
2.父进程创建子进程后，父进程与子进程同时执行(**并发**)。主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序返回，主程序才开始执行。

3.进程通信的方式：1.共享内存区 2.消息传递 3.管道通信 4.共享文件

4.多线程是指在一个程序中可以定义多个线程并同时运行它们，每个线程可以执行不同的任务。多任务时针对操作系统而言的，代表操作系统可以同时执行的程序个数；多线程是针对一个程序而言的，代表一个程序可以同时执行的线程个数，而每个线程可以完成不同的任务。

5.系统中没有运行进程就**一定没有**就绪进程，若系统中未运行进程，则系统很快会选择一个就绪进程运行。只有就绪队列中无进程时，CPU才会处于空闲状态。

6.PCB中记录了有关进程的一些描述信息和控制信息，包括进程标识符、进程当前的状态、优先级、进程放弃CPU时的现场信息，以及指示组成进程的程序和数据在存储器中存放位置的信息、资源使用信息、进程各种队列的链接指针和反映进程之间的隶属关系的信息等。
在操作系统内核中，有一组程序专门用于完成对进程的控制，这些原语至少需要包括创建**新进程原语、阻塞进程原语、唤醒进程原语、终止进程原语**等操作。


***

### 处理机调度

#### 调度的基本概念

#### 调度的层次

1. 高级调度(作业调度)：按照一定的原则从外存上处于后备队列的作业中挑选一个或多个，给它们分配内存、输入\输出设备等必要的资源，并建立相应的进程，以使它们获得竞争处理机的权利。作业调度就是内存与辅存之间的调度。多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。
1. 中级调度(内存调度)：将暂时不能运行的进程调至外存等待，此时进程的状态称为**挂起态**。当它们已具备运行条件而内存又稍有空闲时，中级调度来决定把外存中的进程调入内存，并将其修改为就绪态。中级调度实际上是存储器管理中的对换功能。
1. 低级调度(进程调度)：从就绪队列中选取一个进程，将处理机分配给它

作业调度为进程活动做准备，进程调度使进程正常活动起来。
中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间
作业调度次数少，中级调度次数略多，进程调度频率最高
进程调度是最基本的，不可或缺

#### 调度的目标
1. CPU利用率：CPU有效工作事件/(CPU有效工作事件+CPU空闲等待时间)
1. 系统吞吐量：表示单位时间内CPU完成作业的数量
1. 周转时间：作业完成时间-作业提交时间。带权周转时间：作业周转时间/作业实际运行时间
1. 等待时间：进程处于等待处理机时间之和，等待时间越长，用户满意度就越低
1. 响应时间：只从用户提交请求到系统首次产生响应所用的时间

### 调度的实现

#### 调度程序(调度器)
用于调度和分配CPU的组件称为调度程序，它通常由三部分组成：
1. 排队器：负责将就绪的进程插入响应的就绪队列中
1. 分派器：根据调度程序所需的进程，将其从就绪队列中取出，将CPU分配给新进程
1. 上下文切换器：保存上下文到PCB，恢复CPU现场信息

#### 调度的时机、切换与过程
不能进行进程的调度与切换的情况：
1. 在处理中断的过程中
1. 进程在操作系统的内核临界区中
1. 其他需要完全屏蔽中断的原子操作过程

应该进行进程调度与切换的情况：
1. 发生引起调度条件且当前进程无法进行下去时，可以马上进行调度与切换。若系统旨在这种情况下进行进程调度，则是非剥夺调度。
1. 中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。若操作系统支持这种情况下的进程调度程序，则实现了剥夺方式的调度。

进程调度方式：
1. 非抢占调度方式：又称非剥夺方式
1. 抢占调度方式：又称剥夺方式

#### 闲逛进程
在进程切换时，如果系统中没有就绪进程，就会调度闲逛进程(idle)运行，如果没有其他进程就绪，该进程就一直运行，并在执行过程中测试中断，只要有进程就绪，他就会立刻让出处理机

#### 两种线程的调度
1. 用户级线程调度：操作系统内核只选择进程，并给予时间控制，由进程中的调度程序决定哪个线程运行
1. 内核级线程调度：操作系统内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。

用户级线程的线程切换在同一进程中进行，仅需少量的机器指令；内核级线程的切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。

***

### 典型的调度算法

1. 先来先服务(FCFS)调度算法
1. 短作业优先(SJF)调度算法：平均等待时间，平均周转时间最少，会导致饥饿
1. 优先级调度算法
    1. 非抢占式优先级调度算法
    1. 抢占式优先级调度算法
1. 高响应比优先算法：响应比=(等待时间+要求服务时间)/要求服务时间
1. 时间片轮转调度算法
1. 多级队列调度算法
1. 多级反馈队列调度算法(融合了前几种算法的优点)

### 进程切换
1. 上下文切换
    切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程状态，这个任务称为**上下文切换**。
    1. 挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器
    1. 更新PCB信息
    1. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列
    1. 选择另一个进程执行，并更新其PCB
    1. 跳转到新进程PCB中的程序计数器所指向的位置执行
    1. 恢复处理机上下文
1. 上下文切换的消耗
1. 上下文切换与模式切换



