# 进程与线程

## 2.1 进程与线程

### 进程的概念
为了使参与并发执行的每个程序(含数据)，都能独立地运行，必须为之配置一个专门的数据结构，称为**进程控制块**(Process Control Block,PCB)。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应的，由程序段、相关数据段和PCB三部分构成了**进程实体**(又称进程映像)。
创建进程实质上是创建进程实体中的PCB，撤销进程，实质上是撤销进程的PCB。值得注意的是，进程实体是静态的，进程则是动态的。进程实体反映了进程在某一时刻的状态。

**PCB是进程存在的唯一标志**

从不同的角度，进程的定义是不同的，比较典型的定义有：
1. 进程是程序的一次执行
1. 进程是一个程序机器数据在处理机上顺序执行时所发生的活动
1. 进程时具有独立功能的程序在一个数据集合上的运行的过程，它是系统进行资源分配和电镀的一个独立单位。

引入进程实体的概念之后，我们可以给出如下定义：
**进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

### 进程的组成
+ PCB
    + 进程描述信息
    + 进程控制和管理信息
    + 资源分配清单
    + 处理机相关信息
+ 程序段
    + 程序的代码(指令序列)
+ 数据段
    + 运行过程中产生的各种数据(如：程序中定义的变量)


### 进程的特征
1. 动态性：进程最基本的特性
1. 并发性
1. 独立性：进程是能独立运行的、独立获得资源、独立接收调度的基本单位
1. 异步性：各进程以不可预知的速度向前推进，可能导致运行结果的不确定性
1. 结构性

***

### 进程的状态与转换

#### 进程的状态

1. 运行态：进程正在处理机上运行。CPU会执行该进程对应的程序(执行指令序列)在单处理机中，每个时刻只有一个进程处于运行态
1. 就绪态：进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行，系统中处于就绪态的进程可能有多个，通常将它们排成一个队列，称为就绪队列
1. 阻塞态：又称**等待态**，进程正在等待某一事件而暂停运行，如等待某资源为可用(不包括处理机)或等待输入/输出完成。即使处理机空闲，该进程也不能运行。系统通常将处于阻塞态的进程也排列成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列
1. 创建态：进程正在被创建，尚未转到就绪态。创建进程需要多个步骤：首先申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后把该进程转入就绪态并插入就绪队列。但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。
1. 结束态：进程正从系统中小时，可能是进程正常结束或其他原因停止运行。进程需要结束运行时，系统首先将该进程置为结束态，然后进一步处理资源释放和回收工作

三种基本状态：运行态，就绪态，阻塞态，进程整个生命周期中，大部分事件都处于这三种状态

进程PCB中，会有一个变量state来表示进程当前状态。为了对同一个状态下的各个进程进行同一的管理，操作系统会将各个进程的PCB组织起来。

#### 进程状态的转换

就绪态→运行态：进程被调度
运行态→就绪态：时间片到，或CPU被其他高优先级的进程抢占
运行态→阻塞态:一个主动的过程，等待系统资源分配，或等待某事件发生
阻塞态→就绪态：资源分配到位，等到的事情发生(被动行为)
创建态→就绪态：系统完成进程创建的相关工作
运行态→终止态：进程运行结束，或运行过程中遇到不可修复的错误

#### 进程的组织方式
链接方式：
执行指针：指向当前处于运行态(执行态)的进程
就绪队列指针：指向当前处于就绪态的进程，通常会把优先级高的进程放在队头
阻塞队列指针：指向当前处于阻塞态的进程，很多操作系统中会根据阻塞原因的不同，将阻塞队列分为多个

***

### 进程控制
进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

如何实现进程控制？
使用**原语**，原语是一种特殊的程序，其执行具有“原子性”，即执行过程一气呵成，期间不允许被中断。通过关中断和开中断两个特权指令实现原子性。

#### 进程控制相关的原语

**进程的创建**
+ 创建原语：申请空白PCB，为新进程分配所需资源，初始化PCB，将PCB插入就绪队列

+ 引起进程创建阿事件：
    + 用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程
    + 作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程(作业：放在外存中还未投入运行的程序)
    + 提供服务：用户向操作系统提出某些请求时会新建一个进程处理该请求
    + 应用请求 ：由用户进程主动请求创建一个子进程

**进程的终止**
+ 撤销原语
    + 从PCB集合中找到终止进程的PCB
    + 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程
    + 终止其所有子进程(进程间的关系是树形结构)
    + 将该进程拥有的所有资源归还给父进程或操作系统
    + 删除PCB
+ 引起进程终止的事件
    + 正常结束：进程自己请求终止
    + 异常结束：整数除以0、非法使用特权指令，然后被操作系统强行杀掉
    + 外界干预：用户选择杀掉进程

**进程的阻塞和唤醒**
+ 进程的阻塞
    + 阻塞原语
    + 引起进程阻塞的事件
+ 进程的唤醒
    + 唤醒原语
    + 引起进程唤醒的事件

一个进程是因为何事阻塞就必须因为何事唤醒，因此阻塞原语和唤醒原语应该是成对使用的。

**进程的切换**
+ 切换原语
    + 将运行环境信息存入PCB
    + PCB移入相应队列
    + 选择另一个进程执行，并更新其PCB
    + 根据PCB恢复新近还曾所需的运行环境
+ 引起进程切换的事件
    + 当前进程时间片到
    + 有更高优先级的进程到达
    + 当前进程主动阻塞
    + 当前进程终止

***

### 进程间通信

进程间通信(Inter-Process Communication,IPC)是指两个进程之间产生数据交互。

+ 共享存储
设置一个共享额你存区域，并映射到进程的虚拟地址空间
在通信的进程之间存在一块可直接访问的共享空间。需要保证各个进程对共享存储区的访问是互斥的。
**基于存储区的共享**：操作系统在内存中画出一块共享存储区，数据的形式，存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快、灵活性高，是一种高级通信方式。
**基于数据结构的共享**：共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。
+ 消息传递
进程间的数据狡猾以格式化的消息为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。
    + **直接通信方式**消息发送进程要指明接收进程的ID。
    消息包括消息头和消息体，消息头包括：发送进程ID，接收进程ID、消息长度等格式化的信息。消息体中包含具体的数据。操作系统内核中包含进程的PCB,PCB中包含该进程的消息队列。
    发送原语指明消息的接收者，发送原语会导致操作系统内核接收到消息，并将该消息挂到接收者的消息队列，接收者使用一个接收原语指明接收的消息来自哪一个进程。
    + **间接通信方式**通过“信箱”间接地通信，又称为“信箱通信方式”
    进程P发往进程Q。进程P**发送原语**指明发往哪个信箱，进程Q通过**接收原语**指明从哪个信箱接收消息。可以多个进程往同一个
+ 管道通信
写进程从管道的一边写入数据，读进程从另一边读取数据。
管道是一个特殊的文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区。
写进程写数据和读进程读数据时要遵循先进先出的原则。而共享存储的读写进程可以在共享存储区的任意位置进行读写操作。
一个管道只能支持半双工通信。如果要实现双向同时通信，则需要设置两个管道。
各个进程要互斥的访问管道(由操作系统实现)
当管道被写满时，写进程将被阻塞，直到写进程往管道中写入数据，即可唤醒读进程
管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常由两种解决方案：1.**一个管道允许多个写进程，一个读进程**(2014年408真题高教社官方答案)2.允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据(Linux方案)。在做题时以第一种解决方案为准。
写进程往管道写数据，即使管道没被写满，只要管道没空，读进程就可以从管道读数据
读进程从管道读数据，即使管道没被读空，只要管道没满，写进程就可以向管道写数据


### 线程的概念
有的进程可能需要同时做很多时，而传统的进程只能串行地执行一系列程序。为此，引入了线程，来增加并发度。
引入了线程后，线程就成了程序执行流地最小单位
可以把线程理解为“轻量级进程”
引入线程后，进程只作为除CPU之外地系统资源的分配单元(如打印机、内存地址空间等都是被分配给进程的，而不是分配给线程的)，线程时调度的基本单位。
传统进程机制中，只能进程间并发，引入线程后，各线程之间也可以并发，提升了并发度。
传统的进程间并发，需要切换进程的运行环境，系统开销很大，线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小，引入线程后，并发所带来的系统开销减小

### 线程的实现方式

+ 用户级线程
线程切换的管理是由用户完成的，不需要操作系统的草鱼
线程切换不需要切换操作系统的状态
操作系统无法意识到线程的存在

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

+ 内核级线程
操作系统支持的线程(Kernel-Level Thread,KLT,又称“内核支持的线程”)
1. 内核级线程有操作系统内核管理
1. 内核级线程的切换必须在核心态下才能完成
1. 从操作系统的内核视角能看到内核级线程

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行
缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

+ 多线程模型
在支持内核级线程的操作系统中加入线程库，就可以实现把若干过用户级线程映射到某一个内核级线程。
1. 一对一模型：一个用户级线程对应一个内核级线程(退化成了内核级线程模型)
优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行
缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
2. 多对一模型：多个用户级线程对应一个内核级线程(退化成了用户级线程的模型)，一个用户进程对应一个内核级线程
优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。
3. 多对多模型：n个用户级线程对应m个内核级线程(n≥m)。每个用户进程对应m个内核级线程。
克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户占用太多内核级线程，开销太大的缺点

可以这么理解：
用户级线程是“代码逻辑”的载体：用户级线程对应不同的逻辑功能
内核级线程是“运行机会”的载体：操作系统在分配处理机资源时是以内核级线程为基本单位的
一段代码逻辑只有获得了运行机会才能被COU执行。
一个用户进程对应多个内核级线程时，只有所有的内核级线程都被阻塞，才说这个进程进入了阻塞态。

### 线程的状态与转换
通常只关注就绪态、运行态、阻塞态三种状态
其状态转换的条件与进程相同

### 线程的组织与控制
线程对应的数据结果为**TCB(线程控制块)**
包括以下内容：
+ 线程标识符：TID，与PID类似
+ 程序计数器PC
+ 其他寄存器：线程运行的中间结果
+ 堆栈指针：堆栈保存函数调用信息、局部变量等
+ 线程运行状态：运行/阻塞/就绪
+ 优先级：线程调度、资源分配的参考
其中PC、其他寄存器、堆栈指针在线程切换时要进行保存/恢复

**线程表**(thread table)
可以将多个TCB组织成一张线程表
线程表有多种组织方式：一个进程所包含的线程组成一个表；一个系统中所有的线程组成一个表；同一状态的线程组成一个表等

---

## 习题2.1

2.线程是处理机调度的基本单位，可以独立执行程序。
各个线程共享其所属进程的空间

4.进程与线程的根本区别是动态和静态的特点

6.操作系统是根据进程控制块进行控制和管理的。进程的基本状态和进程的优先权都属于PCB的一部分

9.一个进程释放了一台打印机，它可能会改变另一个等待打印机的进程。
进程执行完毕之后由运行态进入终止态并释放打印机，是因为自身状态改变才释放了打印机，而不是释放打印机导致自身状态改变

12.并发进程失去封闭性，是指并发进程共享变量，器质性结果与速度有关。进程的封闭性是指进程的执行结果只取决于进程本身，与执行速度无关。

15.引入线程后，进程仍然是资源分配的基本单位。内核级线程是处理机调度和分派的单位，线程本身不具有资源，它可以共享所属进程的全部资源。

20.若一个进程实体由PCB、共享正文段、数据堆段、数据栈段组成，请指出下列C语言程序中的内容及相关数据分别处于哪一段中：
全局复制变量：正文段
未赋值的全局变量：栈段
函数调用的实参传递值：栈段
用malloc()要求动态分配的存储区：堆段
常量值：正文段
进程的优先级：PCB

22.系统动态DLL库中的系统线程，被不同的进程所调用，它们是**相同**的线程。同一个系统的进程(线程)可以由系统调用的方法被不同的进程(或线程)多次使用。

23.PCB是进程存在的唯一标志。进程ID，CPU状态(CPU现场信息)，堆栈指针都属于PCB。全局变量不属于PCB。

43.进程可以创建进程和线程，线程只能创建线程。

46.用户级线程：一个线程阻塞时其他线程也会被阻塞。

55.当被阻塞的进程等待的某资源(除处理机外)可用时，进程将被唤醒。

二、
2.父进程创建子进程后，父进程与子进程同时执行(**并发**)。主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序返回，主程序才开始执行。

3.进程通信的方式：1.共享内存区 2.消息传递 3.管道通信 4.共享文件

4.多线程是指在一个程序中可以定义多个线程并同时运行它们，每个线程可以执行不同的任务。多任务时针对操作系统而言的，代表操作系统可以同时执行的程序个数；多线程是针对一个程序而言的，代表一个程序可以同时执行的线程个数，而每个线程可以完成不同的任务。

5.系统中没有运行进程就**一定没有**就绪进程，若系统中未运行进程，则系统很快会选择一个就绪进程运行。只有就绪队列中无进程时，CPU才会处于空闲状态。

6.PCB中记录了有关进程的一些描述信息和控制信息，包括进程标识符、进程当前的状态、优先级、进程放弃CPU时的现场信息，以及指示组成进程的程序和数据在存储器中存放位置的信息、资源使用信息、进程各种队列的链接指针和反映进程之间的隶属关系的信息等。
在操作系统内核中，有一组程序专门用于完成对进程的控制，这些原语至少需要包括创建**新进程原语、阻塞进程原语、唤醒进程原语、终止进程原语**等操作。


***

## 2.2 处理机调度

#### 调度的基本概念

#### 调度的层次

1. 高级调度(作业调度)：按照一定的原则从外存上处于后备队列的作业中挑选一个或多个，给它们分配内存、输入\输出设备等必要的资源，并建立相应的进程，以使它们获得竞争处理机的权利。作业调度就是内存与辅存之间的调度。多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。
1. 中级调度(内存调度)：将暂时不能运行的进程调至外存等待，此时进程的状态称为**挂起态**。当它们已具备运行条件而内存又稍有空闲时，中级调度来决定把外存中的进程调入内存，并将其修改为就绪态。中级调度实际上是存储器管理中的对换功能。
1. 低级调度(进程调度)：从就绪队列中选取一个进程，将处理机分配给它

作业调度为进程活动做准备，进程调度使进程正常活动起来。
中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间
作业调度次数少，中级调度次数略多，进程调度频率最高
进程调度是最基本的，不可或缺

#### 调度的目标
1. CPU利用率：CPU有效工作事件/(CPU有效工作事件+CPU空闲等待时间)
1. 系统吞吐量：表示单位时间内CPU完成作业的数量
1. 周转时间：作业完成时间-作业提交时间。带权周转时间：作业周转时间/作业实际运行时间
1. 等待时间：进程处于等待处理机时间之和，等待时间越长，用户满意度就越低
1. 响应时间：只从用户提交请求到系统首次产生响应所用的时间

### 调度的实现

#### 调度程序(调度器)
用于调度和分配CPU的组件称为调度程序，它通常由三部分组成：
1. 排队器：负责将就绪的进程插入响应的就绪队列中
1. 分派器：根据调度程序所需的进程，将其从就绪队列中取出，将CPU分配给新进程
1. 上下文切换器：保存上下文到PCB，恢复CPU现场信息

#### 调度的时机、切换与过程
不能进行进程的调度与切换的情况：
1. 在处理中断的过程中
1. 进程在操作系统的内核临界区中
1. 其他需要完全屏蔽中断的原子操作过程

应该进行进程调度与切换的情况：
1. 发生引起调度条件且当前进程无法进行下去时，可以马上进行调度与切换。若系统旨在这种情况下进行进程调度，则是非剥夺调度。
1. 中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。若操作系统支持这种情况下的进程调度程序，则实现了剥夺方式的调度。

进程调度方式：
1. 非抢占调度方式：又称非剥夺方式
1. 抢占调度方式：又称剥夺方式

#### 闲逛进程
在进程切换时，如果系统中没有就绪进程，就会调度闲逛进程(idle)运行，如果没有其他进程就绪，该进程就一直运行，并在执行过程中测试中断，只要有进程就绪，他就会立刻让出处理机

#### 两种线程的调度
1. 用户级线程调度：操作系统内核只选择进程，并给予时间控制，由进程中的调度程序决定哪个线程运行
1. 内核级线程调度：操作系统内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。

用户级线程的线程切换在同一进程中进行，仅需少量的机器指令；内核级线程的切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。

***

### 典型的调度算法

1. 先来先服务(FCFS)调度算法
1. 短作业优先(SJF)调度算法：平均等待时间，平均周转时间最少，会导致饥饿
1. 优先级调度算法
    1. 非抢占式优先级调度算法
    1. 抢占式优先级调度算法
1. 高响应比优先算法：响应比=(等待时间+要求服务时间)/要求服务时间
1. 时间片轮转调度算法
1. 多级队列调度算法
1. 多级反馈队列调度算法(融合了前几种算法的优点)

### 进程切换
1. 上下文切换
    切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程状态，这个任务称为**上下文切换**。
    1. 挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器
    1. 更新PCB信息
    1. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列
    1. 选择另一个进程执行，并更新其PCB
    1. 跳转到新进程PCB中的程序计数器所指向的位置执行
    1. 恢复处理机上下文
1. 上下文切换的消耗
1. 上下文切换与模式切换

***

## 习题 2.2

3.先来先服务调度算法有利于CPU繁忙型作业，而不利于I/O繁忙型作业。I/O繁忙会导致作业频繁的请求I/O操作，导致操作完成后还需要重新进行排队等待调度。

13.I/O型作业的优先权应该高于计算型作业的优先权。I/O工作和计算工作可以并行运行，因此应该让I/O设备尽早地开始工作。且I/O作业属于交互较多的作业，需要系统及时响应，如玩游戏等。
在动态优先权中，随着进程执行时间的增加，其优先权降低，防止长进程长时间独占CPU。

15.作业是用户提交的，进程是由系统自动生成的，除此之外，两者的区别是：前者以用户任务为单位，后者以操作系统控制为单位。用户提交的一个作业可能对应多个进程。

20.对短进程不利的算法是：先来先服务调度算法。如果由一个长进程先到，对后到的短进程不利。

22.UNIX属于分时操作系统。
中断发生时，由硬件保护并更新程序计数器(PC)，而不是由软件完成，主要是为了保证系统运行可靠正确。

26.当进程处于临界区时，说明进程正在占用处理机，只要不破坏临界资源的使用规则，就不会影响处理机的调度。比如，通常访问的临界资源可能是慢速的外设(如打印机)，若在进程访问打印机时，不能能进行处理机调度，则系统的性能会非常差。

二、
8.时间片轮转调度算法计算式要注意进程到达就绪队列的时间。

***

## 2.3 同步与互斥

### 同步与互斥的基本概念

一次仅允许一个进程使用的资源称为临界资源

可以把临近资源的访问过程分为4个部分：
1. 进入去：在进入区要检查是否可以进入临近区，若能进入临界区，则应设置正在访问临界区的标志，以组织其他进程同时进入临界区
1. 临界区：进程中访问临界资源的那段代码，又称临界段
1. 退出区：将正在访问临界区的标志清除
1. 剩余区：代码中的其余部分

**同步**：同步亦称直接制约关系
**互斥**：互斥也称简介制约关系

为禁止两个进程同时进入临界区，同步机制应遵循以下准则：
1. 空闲让进：临界区空闲时，允许一个请求进入临界区的进程立刻进入临界区
1. 忙则等待：已有进程进入临界区时，其他试图进入临界区的进程必须等待
1. 有限等待：对请求访问的进程，应保证能在有限时间内进入临界区
1. 让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待

### 实现临界区互斥的基本方法

#### 软件实现方法
1. 单标志法:两个进程必须交替进入
1. 双标志先检查法：用一个flag数组记录两个进程是否在临界区中，先检查对方是否占用临界资源，如果没有，则自己占用，否则循环等待。 缺点：检查和占用不是一气呵成的，可能导致两个同时进入临界区
1. 双标志后检查法：用一个flag数组记录两个进程是否在临界区中，要进入临界区时，先将自己的flag设为true，再检查对方是否在临界区中。 缺点：可能导致双方同时设为true，两个都无法进入临界区的情况。
1. Peterson's Algorithm：皮特森算法，是算法一和算法三思想的结合。利用flag解决临界资源的互斥访问，利用turn解决“饥饿”问题。


#### 硬件实现方法
1. 中断屏蔽方法：利用开关中断指令  优点：简单高效 缺点：不适用于多处理机(关中断指令只对关中断的处理机有用，对于另一个处理机来说，其上的进程仍然可能访问临界区)，只适用于操作系统内核进程，不适用于用户进程(因为开关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)
1. 硬件指令方法
    1. TestAndSet，或TestAndLock(TSL)指令:用硬件实现的，执行过程不允许被中断，只能一气呵成。old用来存放lock原来的值， 无论之前lock是否上锁，都将lock置为true， 最后返回lock原来的值。使用硬件将检查和上锁变成了一气呵成的原子操作。 适用于多处理器环境。 缺点：不满足让权等待的原则，会导致忙等待
    1. Swap指令：有的地方也叫Exchange指令，或简称XCHG指令。swap指令的作用是交换两个变量的值。其逻辑上与TSL指令没有什么区别。
优点：适用于任意数目的进程，而不管是单处理机还是多处理机；简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每一个临界区设立一个布尔变量。
缺点：不能实现让权等待，会导致饥饿现象



#### 互斥锁
锁是一个bool型的变量，只有ture和false两个值
mutex lock
函数acquire()获得锁
函数release()释放锁

互斥锁通常采用硬件机制来实现
互斥锁的主要缺点是忙等待，违反了让权等待的原则。互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待。
需要循环忙等的互斥锁，都可成为自旋锁，如TSL指令、swap指令、单标志法

优点：等待锁的期间不需要切换进程的上下文，如果上锁的时间短，则等待代价很低
常用于多处理机系统，一个核忙等，其他核照常工作，并快速释放临界区
不太适用于单处理机系统，忙等的过程中不可能解锁。

#### 信号量(Dijkstra提出)
wait原语 signal原语 对应P操作和V操作
1. 整型信号量：用一个整数来表示某一种资源的数量，存在忙等现象
1. 记录型信号量：定义了一个进程链表L，用来链接所有等待该资源的进程
1. 利用信号量实现同步
1. 利用信号量实现进程互斥
1. 利用信号量实现前驱关系

#### 生产者消费者问题

## 2.4 死锁

### 死锁的概念

在并发环境下，各个进程因为互相竞争资源导致个进程都阻塞，无法向前推进的现象
发生死锁的进程一定是处于阻塞态的，至少有两个或以上的进程同时死锁

饥饿：进程长期得不到想要的资源，某进程无法向前推进的现象。可能只有一个进程饥饿，可能是阻塞态也可能是就绪态
死循环：某进程执行过程中一直跳不出某个循环的现象，可能是处于运行态的

### 产生死锁的条件
必须满足全部四个条件
1. 互斥条件：只有对必须互斥使用的资源的争夺才会导致死锁。像内存、扬声器这样可以同时让多个进程共享的资源是不会导致死锁的。
1. 不剥夺条件：进程所获得的资源，不能由其他进程强行夺走，只能主动释放
1. 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源和请求，而该资源又被其他进程占有，吃屎请求进程被阻塞，但有对自己已有的资源保持不妨
1. 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求

发生死锁时，一定有循环等待，但是发生循环等待时未必死锁

### 什么时候会发生死锁

1. 对系统资源的竞争
1. 进程推进顺序非法
1. 信号量使用不当也会造成死锁

### 死锁的处理策略

1. 预防死锁：破坏死锁产生的四个必要条件中的一个
1. 避免死锁：用某种方法防止系统进入不安全状态
1. 死锁的检测和解除：允许死锁发生，操作系统会负责检测除死锁的发生，并进行死锁的解除

### 预防死锁

破坏死锁产生的四个必要条件中的某一个

1. 破坏互斥条件：SPOOLing技术，可以把独占设备在逻辑上改造成共享设备。缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还不许保护这种互斥。因此，很多时候都无法破坏互斥条件
1. 破坏不剥夺条件：
    1. 当某个进程请求新的资源得不到满足时，他必须立即释放保持的所有资源，待以后需要时再重新申请
    1. 当某个进程需要的资源被其他进程所占有时，可以由操作系统辅助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。
缺点：1. 实现复杂 2.释放已获得的资源可能造成前一阶段的工作失效。因此这种方法只适用于易保存和恢复状态的资源，如CPU。 3.反复释放和申请资源，会增加系统开销，降低系统吞吐量 4. 若采用方案1，如果得不到某种资源，之前的资源就要全部放弃，以后再重新申请，如果反复发生这种情况，就可能导致该进程出现饥饿现象 
1. 破坏请求和保持条件：可以采用静态分配方法，即进程再运行前申请它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，这个进程就不会再请求别的任何资源了
缺点：资源利用率低，可能导致某些进程饥饿。
1. 破坏循环等待条件：可以采用顺序资源分配法，给系统资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。只有拥有小编号资源的进程才能申请更大编号的资源，但反过来是不行的，从而就不会产生循环等待的现象
缺点：1.不方便增加新的设备 2.进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费 3.必须按规定次序申请资源，用户编程麻烦

### 避免死锁
能找到安全序列，系统就处于安全状态
如果找不到安全序列，系统就处于不安全状态，但不安全状态不等于死锁，有可能进程归还资源，使系统重新回到安全状态
不安全状态未必发生死锁，发生死锁时一定是在不安全状态

#### 银行家算法(Dijkstra提出)
核心思想：在进程提出资源申请时，先判断此次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

MAX矩阵：进程最多需要多少资源
Allocation矩阵：系统已经给进程分配了多少资源
Need矩阵：最多还需要多少资源的矩阵
Available:系统中剩余的资源数量

算法步骤：
1. 检查此次申请是否超过了之前声明的最大需求数
1. 检查此时系统中剩余的可用资源是否还能满足这次需求
1. 试探着分配，更改各数据结构
1. 用安全性算法检查此次分配是否会导致系统进入不安全状态

安全性算法步骤：
检查当前剩余的可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。
不断重复上述过程，看最终是否能让所有进程都加入安全序列。

### 死锁的检测和解除

1. 用某种数据结构来保存资源的请求和分配信息
1. 提供一种算法，利用上述信息来检测系统是否已进入死锁状态

两种结点：
+ 进程结点：对应一个进程
+ 资源结点：对应一类资源，一类资源可能有多个

两种边：
+ 进程结点→资源结点：表示进程想申请机构资源(每条边代表一个)
+ 资源结点→进程结点：表示已经为进程分配了几个资源(每条边代表一个)

检查死锁的算法：
1. 在资源分配图中，找出既不阻塞又不是孤点的进程P1,消去它所有的请求边和分配边，使之称为孤立的点。
1. 如果所有的边都能被消除，则称该图是完全可简化的

**死锁定理**k.：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁

**解除死锁的方法**：
并不是系统中所有的进程都处于死锁状态

1. 资源剥夺法。挂起(暂时放到外存上)某些死锁进程，并剥夺它的资源，将这些资源重新分配。但应防止被挂起的进程长期得不到资源导致饥饿的情况。
1. 撤销进程法：强制撤销部分、甚至全部死锁进程。优点：实现简单。但付出的代价可能很大，有一些已经运行了很长时间的进程可能功亏一篑
1. 进程回退法，让一个或多个死锁进程回退到足以避免死锁的地步。这就要求操作系统记录进程的历史信息，设置还原点。

如何决定对哪一个进程进行操作：
1. 进程优先级
1. 已执行多长时间
1. 还要多久能完成
1. 进程已经使用了多少资源
1. 进程是交互式的还是批处理式的
